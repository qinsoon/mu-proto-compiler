// expect to find 'getArity()', 'getChild(int)', 'getOpcode()' in the node
// IRTreeNode

// as prefix of generated MC nodes
.target X64

.mc_cond_jump {je jne} {jl jge} {jle jg}
.mc_uncond_jump jmp
.mc_ret ret
.mc_mov mov cmovlt cmovgt cmoveq movsd
.mc_nop nop

// registers
.gpr rax rbx rcx rdx rdi rsi r8 r9 r10 r11 r12 r13 r14 r15
.gpr_param rdi rsi rdx rcx
.gpr_ret rax rdx

// _|_|_|_|  _|      _|  _|_|_|  _|_|_|_|_|      _|_|_|    _|    _|  _|        _|_|_|_|    _|_|_|
// _|        _|_|  _|_|    _|        _|          _|    _|  _|    _|  _|        _|        _|      
// _|_|_|    _|  _|  _|    _|        _|          _|_|_|    _|    _|  _|        _|_|_|      _|_|  
// _|        _|      _|    _|        _|          _|    _|  _|    _|  _|        _|              _|
// _|_|_|_|  _|      _|  _|_|_|      _|          _|    _|    _|_|    _|_|_|_|  _|_|_|_|  _|_|_|  
// generated from http://www.kammerl.de/ascii/AsciiSignature.php

stmt : NOP
> nop
0

stmt : PSEUDO_ASSIGN(reg op)
// mov
> mov P[1] -> P[0]
1

stmt : op
0

reg : op
0

op : BRANCH(label)
> jmp P[0]
1

op : BRANCH2(value label label)
// cmp, jcc
> test P[0] $1
> je  P[1]
> jmp P[2]
2

op : BRANCH2(cmpSltRes label label)
// cmp, jcc
> jl  P[1]
> jmp P[2]
1

op : BRANCH2(cmpSleRes label label)
> jle P[1]
> jmp P[2]
1

op : BRANCH2(cmpSgtRes label label)
// cmp, jcc
> jg  P[1]
> jmp P[2]
1

op : BRANCH2(cmpSgeRes label label)
> jge P[1]
> jmp P[2]
1

op : BRANCH2(cmpEqRes label label)
// jcc
> je  P[1]
> jmp P[2]
1

op : BRANCH2(cmpFoltRes label label)
> jb P[1]
> jmp P[2]
1

// ********************************
// SLT 
// ********************************

// 2nd op should always be reg
cmpSltRes : SLT(reg imm)
> cmp P[1] P[0]
1

cmpSgeRes : SLT(imm reg)
> cmp P[0] P[1]
1

cmpSltRes : SLT(reg reg)
> cmp P[1] P[0]
1

cmpSltRes : SLT(imm imm)
> mov P[0] -> %tmp_reg[0]
> cmp P[1] %tmp_reg[0]
2

// ********************************
// FOLT
// ********************************

cmpFoltRes : FOLT(reg imm)
> comisd P[1] P[0]
1

cmpFogeRes : FOLT(imm reg)
> comisd P[0] P[1]
1

cmpFoltRes : FOLT(reg reg)
> comisd P[1] P[0]
1

cmpFoltRes : FOLT(imm imm)
> movsd P[0] -> %tmp_reg[0]
> comisd P[1] %tmp_reg[0]
2

// ********************************
// SGT
// ********************************

cmpSgtRes : SGT(reg imm)
> cmp P[1] P[0]
1

cmpSleRes : SGT(imm reg)
> cmp P[0] P[1]
1

cmpSgtRes : SGT(reg reg)
> cmp P[1] P[0]
1

cmpSgtRes : SGT(imm imm)
> mov P[0] -> %tmp_reg[0]
> cmp P[1] %tmp_reg[0]
2

// ********************************
// EQ 
// ********************************

cmpEqRes: EQ(reg reg)
> cmp P[0] P[1]
1

cmpEqRes: EQ(imm reg)
> cmp P[0] P[1]
1

cmpEqRes: EQ(reg imm)
> cmp P[1] P[0]
1

cmpEqRes: EQ(imm imm)
> mov P[1] -> %tmp_reg[0]
> cmp P[0] %tmp_reg[0]
2

op : RET2(value)
// mov, ret
> mov P[0] -> %ret_reg[0]
> ret
2

// ********************************
// PSEUDO OP 
// ********************************

op : PARAM
// mov
> mov %param_reg[P(InstParam).getIndex()] -> %res_reg
1

op : PHI(value label value label)
> mcphi P[0] P[1] P[2] P[3] -> %res_reg
1

// ********************************
// BIN OP 
// ********************************

op : SREM(value value)
// mov, div, mov
> xor %rdx %rdx -> %rdx
> mov P[0] -> %rax
> idiv P[1] -> %rdx
> mov %rdx -> %res_reg
4

op : ADD(value value)
// add
> mov P[0] -> %res_reg
> add %res_reg P[1] -> %res_reg
2

// ********************************
// FLOATING POINT
// ********************************

op : FADD(value value)
> movsd P[0] -> %res_reg
> addsd %res_reg P[1] -> %res_reg
2

op : FDIV(value value)
> movsd P[0] -> %res_reg
> divsd %res_reg P[1] -> %res_reg
2

op : SITOFP(value)
> cvtpi2pd P[0] -> %res_reg
1

op : FPTOSI(value)
> cvtpd2pi P[0] -> %res_reg
1

// ********************************
// NON-EMIT RULEs
// ********************************

value : reg
0

reg : op
0

imm : INT_IMM
0

imm : FP_IMM
0

value : imm
0

reg : REG
0

label : LABEL
0

// _|      _|    _|_|_|      _|_|_|    _|_|_|_|  _|_|_|_|  _|_|_|  _|      _|  _|_|_|_|
// _|_|  _|_|  _|            _|    _|  _|        _|          _|    _|_|    _|  _|      
// _|  _|  _|  _|            _|    _|  _|_|_|    _|_|_|      _|    _|  _|  _|  _|_|_|  
// _|      _|  _|            _|    _|  _|        _|          _|    _|    _|_|  _|      
// _|      _|    _|_|_|      _|_|_|    _|_|_|_|  _|        _|_|_|  _|      _|  _|_|_|_|

// ********************************
// MOV
// ********************************

.mc_def mov = {
	GPR = GPR;
	"movq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmovlt = {
	GPR = GPR;
	"cmovltq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmovgt = {
	GPR = GPR;
	"cmovgtq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmoveq = {
	GPR = GPR;
	"cmoveqq WS OP COMMA OP", OP[0], OP_REG;
}

// ********************************
// COMPARISON
// ********************************

.mc_def cmp = {
	GPR GPR;
	"cmpq WS OP COMMA OP", OP[0], OP[1];
}

.mc_def test = {
	GPR GPR;
	"testq WS OP COMMA OP", OP[0], OP[1];
}

// ********************************
// BRANCH
// ********************************

.mc_def jmp = {
	"jmp WS OP", OP[0];
}

.mc_def je = {
	"je WS OP", OP[0];
}

.mc_def jne = {
	"jne WS OP", OP[0];
}

.mc_def jl = {
	"jl WS OP", OP[0];
}

.mc_def jle = {
	"jle WS OP", OP[0];
}

.mc_def jg = {
	"jg WS OP", OP[0];
}

.mc_def jge = {
	"jge WS OP", OP[0];
}

.mc_def jb = {
	"jb WS OP", OP[0];
}

.mc_def ret = {
	"ret";
}

// ********************************
// BIN OP
// ********************************

.mc_def idiv = {
	GPR;
	"idivq WS OP", OP[0];
}

.mc_def add = {
	GPR = GPR GPR;
	"addq WS OP COMMA OP", OP[1], OP[0];
}

.mc_def xor = {
	GPR = GPR GPR;
	"xorq WS OP COMMA OP", OP[1], OP[0];
}

// ********************************
// FLOATING POINT
// ********************************

.mc_def movsd = {
	DP = DP;
	"movsd WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def addsd = {
	DP = DP DP;
	"addsd WS OP COMMA OP", OP[1], OP[0];
}

.mc_def divsd = {
	DP = DP DP;
	"divsd WS OP COMMA OP", OP[1], OP[0];
}

.mc_def cvtpi2pd = {
	DP = GPR;
	"cvtpi2pd WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cvtpd2pi = {
	GPR = DP;
	"cvtpd2pi WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def comisd = {
	DP DP;
	"comisd WS OP COMMA OP", OP[0], OP[1];
}

// misc

.mc_def nop = {
	"nop";
}

.mc_def mcphi = {
	"";
}