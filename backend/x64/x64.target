// expect to find 'getArity()', 'getChild(int)', 'getOpcode()' in the node
// IRTreeNode

// as prefix of generated MC nodes
.target X64

.mc_cond_jump je jne jl jge jle jg
.mc_uncond_jump jmp
.mc_ret ret
.mc_mov mov cmovlt cmovgt cmoveq

// registers
.gpr rax rbx rcx rdx rdi rsi r8 r9 r10 r11 r12 r13 r14 r15
.gpr_param rdi rsi rdx rcx
.gpr_ret rax rdx

stmt : PSEUDO_ASSIGN(reg op)
// mov
> mov P[1] -> P[0]
1

stmt : op
0

reg : op
0

op : BRANCH(label)
> jmp P[0]
1

op : BRANCH2(value label label)
// cmp, jcc
> test P[0] $1
> je  P[1]
> jne P[2]
2

op : BRANCH2(cmpSltRes label label)
// cmp, jcc
> jl  P[1]
> jge P[2]
1

op : BRANCH2(cmpSleRes label label)
> jle P[1]
> jg P[2]
1

op : BRANCH2(cmpSgtRes label label)
// cmp, jcc
> jg  P[1]
> jle P[2]
1

op : BRANCH2(cmpSgeRes label label)
> jge P[1]
> jl P[2]
1

op : BRANCH2(cmpEqRes label label)
// jcc
> je  P[1]
> jne P[2]
1

// *** SLT ***

// 2nd op should always be reg
cmpSltRes : SLT(reg imm)
> cmp P[1] P[0]
1

cmpSgeRes : SLT(imm reg)
> cmp P[0] P[1]
1

cmpSltRes : SLT(reg reg)
> cmp P[1] P[0]
1

cmpSltRes : SLT(imm imm)
> mov P[0] -> %tmp_reg[0]
> cmp P[1] %tmp_reg[0]
2

// *** SGT ***

cmpSgtRes : SGT(reg imm)
> cmp P[1] P[0]
1

cmpSleRes : SGT(imm reg)
> cmp P[0] P[1]
1

cmpSgtRes : SGT(reg reg)
> cmp P[1] P[0]
1

cmpSgtRes : SGT(imm imm)
> mov P[0] -> %tmp_reg[0]
> cmp P[1] %tmp_reg[0]
2

// *** EQ ***

cmpEqRes: EQ(reg reg)
> cmp P[0] P[1]
1

cmpEqRes: EQ(imm reg)
> cmp P[0] P[1]
1

cmpEqRes: EQ(reg imm)
> cmp P[1] P[0]
1

cmpEqRes: EQ(imm imm)
> mov P[1] -> %tmp_reg[0]
> cmp P[0] %tmp_reg[0]
2

// *** conditional move ***

//op : SLT(value value)
// mov cmp cmov
//> mov $0 -> %res_reg
//> cmp P[0] P[1]
//> cmovlt $1 -> %res_reg
//3

//op : SGT(value value)
// mov cmp cmov
//> mov $0 -> %res_reg
//> cmp P[0] P[1]
//> cmovgt $1 -> %res_reg
//3

//op : EQ(value value)
// mov cmp cmov
//> mov $0 -> %res_reg
//> cmp P[0] P[1]
//> cmoveq $0 -> %res_reg
//3

op : RET2(value)
// mov, ret
> mov P[0] -> %ret_reg[0]
> ret
2

op : PARAM
// mov
> mov %param_reg[P(InstParam).getIndex()] -> %res_reg
1

op : SREM(value value)
// mov, div, mov
> xor %rdx %rdx -> %rdx
> mov P[0] -> %rax
> idiv P[1] -> %rdx
> mov %rdx -> %res_reg
4

op : PHI(value label value label)
> mcphi P[0] P[1] P[2] P[3] -> %res_reg
1

op : ADD(value value)
// add
> mov P[0] -> %res_reg
> add %res_reg P[1] -> %res_reg
2

value : reg
0

value : INT_IMM
0

imm : INT_IMM
0

value : imm
0

reg : REG
0

label : LABEL
0

// *******
// machine code define
// *******

// mov

.mc_def mov = {
	"movq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmovlt = {
	"cmovltq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmovgt = {
	"cmovgtq WS OP COMMA OP", OP[0], OP_REG;
}

.mc_def cmoveq = {
	"cmoveqq WS OP COMMA OP", OP[0], OP_REG;
}

// comparison

.mc_def cmp = {
	"cmpq WS OP COMMA OP", OP[0], OP[1];
}

.mc_def test = {
	"testq WS OP COMMA OP", OP[0], OP[1];
}

// branch

.mc_def jmp = {
	"jmp WS OP", OP[0];
}

.mc_def je = {
	"je WS OP", OP[0];
}

.mc_def jne = {
	"jne WS OP", OP[0];
}

.mc_def jl = {
	"jl WS OP", OP[0];
}

.mc_def jle = {
	"jle WS OP", OP[0];
}

.mc_def jg = {
	"jg WS OP", OP[0];
}

.mc_def jge = {
	"jge WS OP", OP[0];
}

.mc_def ret = {
	"ret";
}

// arithmetic/mul/div

.mc_def idiv = {
	"idivq WS OP", OP[0];
}

.mc_def add = {
	"addq WS OP COMMA OP", OP[1], OP[0];
}

// misc

.mc_def mcphi = {
	"";
}